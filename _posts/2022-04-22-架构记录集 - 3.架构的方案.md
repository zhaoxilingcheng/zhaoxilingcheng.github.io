---
layout: post
title: 架构记录集 - 3.架构的方案
date: 2022-04-22
categories: java
tags: [java、架构]
description: 无。
---

# 架构

## 架构的目的

为了解决软件复杂性带来的一系列问题，识别出业务的关键要求，在成本和要求间做一个平衡的设计。  
减少需求新增或变更时带来的原功能的影响、减少实现新功能的成本。

软件复杂性带来的问题：
1. 不可用
2. 性能低下
3. 业务响应能力差

### 高可用
保证系统无中断，一致能响应。

通过冗余机器来实现，通过加数量来降低故障率以实现高可用。
```
              +-----------+              
              |   tasks   |              
              +-----------+              
                    |                    
                    V                    
          /-------------------\          
      +---|    load balance   |---+      
      |   \-------------------/   |      
      |                           |      
      V                           V      
+-----------+               +-----------+
|   node1   |      ....     |   nodeN   |
+-----------+               +-----------+
      |                           |      
      +----------->end<-----------+ 
常见分配算法有： 轮询、权重、hash取模、性能最优等
```
当然会产生一些问题，数据的同步是需要时间的，如何保证数据的一致性。
cap:   
一致性、可用性、分区容错性

当通过冗余来实现高可用时，就需要判断节点的数据是否是正确的。常见的解决方法为：
1. 主备 主机的所有操作都备份一份，然后主机故障时进行切换备机
2. 主从 主机负责读写，从机负责读 缺点（由于数据的同步需要时间，客户端需要一定的策略保证数据读取的正确）
3. 集群   
   3.1 数据量少的方案  
   zookeeper， 选出一个主节点来进行数据写入操作。  
   3.2 数据量大的方案  
   hadoop， 拥有一个分配节点(name node)来进行分配数据写入到某个具体的节点，然后给该节点进行备份。可以实现横向拓展。

### 高性能

#### 单机的发展过程

手动输入、计算、输出 -> 批处理 -> 多进程 -> 多线程 -> 多核

#### 集群的复杂度

单机无法满足任务的计算时，集群挑起了旗杆, 本质上还是分而治之。

##### 任务分配:

将任务按照一定的规则分配到多个计算节点上
同高可用的图是一样的， 高可用是冗余机器实现低故障率， 高性能是通过增加机器提升处理能力。
```
              +-----------+              
              |   tasks   |              
              +-----------+              
                    |                    
                    V                    
          /-------------------\          
      +---|    load balance   |---+      
      |   \-------------------/   |      
      |                           |      
      V                           V      
+-----------+               +-----------+
|   node1   |      ....     |   nodeN   |
+-----------+               +-----------+
      |                           |      
      +----------->end<-----------+ 
```

当任务量变得单分配者无法满足时，将分配机器进行集群。

```
               +-----------+              
               |   tasks   |              
               +-----------+              
                     |                    
                     V                    
          /-------\     /-------\          
      +---| load1 | ... | loadN |---+      
      |   \-------/     \-------/   |      
      |                             |      
      V                             V      
+-----------+                  +-----------+
|   node1   |       ....       |   nodeN   |
+-----------+                  +-----------+
      |                             |      
      +------------->end<-----------+ 
```

##### 任务拆分
当单任务太过复杂，单节点的能力无法高效的处理时，可以将单任务进行拆分成多个子任务，任务越简单，性能天花板越高。  
以新零售举例，可以拆分出 商品、库存、订单、营销、会员等业务
```                 
          /---------------\          
      +---|    big task   |---+      
      |   \---------------/   |      
      |                       |      
      V                       V      
+-----------+           +-----------+
|   task1   |    ....   |   taskN   |
+-----------+           +-----------+
      |                       |      
      +--------->end<---------+ 
```

任务拆分可以按照子任务的个体性能瓶颈来进行集群拓展简单快速的提升性能。


### 拓展性
如何应对未来变化的部分，尽量减少对现有功能的影响。  
需要将变化和稳定进行拆分，

#### 常见的技术解决方案
1. 依赖于稳定的抽象，而不依赖具体实现。
2. 可插拔的流程配置

#### 业务解决方案
领域驱动设计，先统一业务语言，梳理实体、行为与值对象，进行划分域，将各代码层进行防腐。

1. 采用一个可靠的代码结构分层，这样变化就会沉入到某一层内
2. 将功能按域、实体进行拆分，使业务高内聚（微内核）。


### 独白
ps: 如果您有任何问题，请留言，个人技术不到位，所以写的东西存在很多问题，记录一下自己的思路。如果有不足还请多指点，十分感激。我会及时补充和修改、回复。